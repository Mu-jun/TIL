# 소프트웨어 설계와 추상정, 구조적 사고
- [강의링크](https://www.inflearn.com/course/lecture?courseSlug=%EC%9D%B8%ED%94%84%EC%BD%982023-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B0&unitId=177911)
- 발표자 : 코발트 / 이선협

## 1. 개발자와 프로그래밍
- 프로그램 :
  - 사전적 의미 : 원하는 결과를 이루기 위해 수행되는 일의 계획
  - 문제를 해결하기 위해 만들어짐.
    - 비즈니스는 문제를 해결해주고 이익을 얻는 행위
   
- 문제 해결을 위한 프로세스
  - 전체 과정 :
    - 문제 이해/분석 => 설계 => 구현 => 평가 => 문제 이해/분석
  - 문제 이해/분석 => 설계
    - 문제를 파악하고 컴퓨터 시스템에 적합하게 설계하는 과정
  - 설계 => 구현 => 평가
    - 컴퓨터 시스템으로 전산화를 하는 과정

- 결국 어떠한 문제를 발견하더라도 **유연하게 해결할 수 있는 방법론**을 익히는 것이 중요함
  - 유연하게 해결할 수 있는 방법론 = 추상적, 구조적 사고
 
## 2. 추상적, 구조적 사고
- 추상 : 여러가지 사물이나 개념에서 **공통**되는 특성이나 속성 따위를 **추출**하여 파악하는 작용
  - 결국 사물을 **단순화**하고 **재해석**하는 것 => **요소 환원주의**
  - 현상/물체/행위 => 분석/해체 => (의도와 목적에 맞게) 결합
  - 주의 : 과도한 추상화를 실제 모습을 알 수 없게 한다.

- 구조적 사고 : 내용을 **겹치지 않고 빈틈없이 정리**하는 것
  - 목적에 따라 묶고 나누고 정렬하고 중복을 제거 => **MECE 프레임워크**
  - 개발을 하다보면 완벽하게 안 겹치게 할 수 없음.
    - 성능을 위해 의도적인 반정규화 등

## 3. 구체적인 방법
### 탑다운(Top-Down) ; 하향식 접근법
- **큰 문제**를 정의하고 **작은 문제로 분해**하여 세부적인 문제를 찾아 해결

### 바텀업(Bottom-Up) ; 상향식 접근법
- **세부적인 문제를 해결**하여 **전체 문제의 답**을 찾음.

> 탑다운과 바텀업은 상호보완적임.  
> (내 생각 : 탑다운으로 문제를 찾고, 바텀업으로 문제를 해결?)

## 4. 모델
- 세상을 표현하기 위한 방법
### 모델링
- Classification ; 분류
  - Categorizing : 비슷한 요소끼리 묶는 것
  - Grouping : 특정 기준에 따라서 묶는 것
- Abstraction ; 추상화
  - 어떻게 바라볼 것인가?
  - Projection : 요소에서 필요한 내용을 뽑아내는 것 ex) Class, Domain Model, ...
  - Layering : 요소를 계층으로 나누는 것, 한 요소를 여러 관점으로 볼 수 있다. ex) OSI 7 Layer, Layered Architecture
- Generalization
  - 어떤 공통점이 있는가?
  - Pattern : 비슷한 사용 사례를 묶어 공통적으로 쓸 수 있게 하는 것 ex) Design Patten, Function, ...

> 모델링을 할 때 추상화와 구조화는 동시에 발생한다.  
> 이미 추상화, 구조화된 것을 다시 추상화, 구조화할 수 있다.

## 5. 프레임워크(Framework)
- 틀에 맞춰 작업하는 것
- 같은 문제라도 틀에 따라서 문제에 접근하고 해결하는 방식이 달라진다.
- 문제 => 분석/분해 => 결합 과정을 통해

## 6. 소프트웨어 설계
### 도메인 모델링
- 도메인 : 우리가 해결할 **문제**에 대한 비즈니스 전문 지식
- 모델링 : 세상을 **표현**하는 방법
- 도메인 모델링 : 비즈니스를 프로그램 세계로 표현하는 것
- 요구사항 수집 => 전문지식 습득 => 모델링 => 피드백 => 요구사항 수집

### 아키텍처
- 소프트웨어의 구성요소
  - Program | Subsystem | Module | Component & Interface | Logic
  - Subsystem | Module | Component & Interface => 아키텍처 적용부분
- 개발자가 일을 하는 방법
  - 어떻게 만드는가?
  - 업무를 어떻게 나누는가? => 조직의 상황에 따라서 분해하여 나눔.
- 요구사항/조직파악 => 컨셉 => 구현 => 피드백 => 요구사항/조직파악
- 요구사항과 조직에 따라 달라질 수 있다.
- 하향식으로 구체화하는 것이 좋다.
- 구현 단계
  1. Application 구성요소
  2. Subsystem 구성요소
  3. Subsystem 간 통신 방법
  4. Application 간 통신 방법
  5. 외부 시스템과 통신 방법

### 코드 작성
- 패러다임 : 인식의 체계, 사물에 대한 이론적 틀이나 체계
  - 우리는 우리가 알고 있는 인식의 틀 안에서 사고한다.
- 프로그래밍 패러다임 : 프로그램을 바라보는 관점. ex) 명령형 프로그래밍, 선언형 프로그래밍, ...
- 모든 프로그램은 **순차, 분기, 반복, 참조**로 구성됨.
  - 절차적 프로그래밍 => 순차 : Procedure | 분기 : if, switch | 반복 : for, while | 참조 : Mutable
  - 함수형 프로그래밍 => 순차 : Function | 분기 : Pattern Matching | 반복 : Recursion | 참조 : Immutable
- 객체지향 패러다임 : 객체를 기준으로 추상화
  - 프로그램은 객체들의 유기적인 통신을 통해 이루어지기 때문에 객체를 올바르게 만들어 상호작용하도록 만듬.
- 함수형 패러다임 : 함수를 기준으로 추상화
  - 프로그램은 하나의 함수이며 복잡한 연선을 위해서 여러 함수의 합성을 통해 프로그램을 만듬.

### 로직
- Usecase : 로직이 어떤 기능을 위해 존재하는가?
  - 기능이 어떤 프로세스로 흘러가는가?
  - 프로세스로 나누거나 합침.
- Aspect : 로직인 어떤 관점에서 사용되는가?
- Function : 로직을 구성하는 함수

### 리팩토링
- 관점 :
  - 패러다임 : 이 코드가 어떤 패러다임을 따르는가?
  - 코드 크기 : 이 코드의 크기가 큰가?
  - 소유권 : 이 코드를 누가 관리하는가?
  - 중복 여부 : 이 코드가 중복 코드인가?
  - 수정 가능성 : 추후에 이 코드가 수정될 가능성이 확률적으로 높은가?
  - 의존 : 이 코드가 무언가를 읜존하거나 의존 당하는가?
- 방법 :
  - 추상화 : 숨길 것인가? 드러낼 것인가?
  - 구조화 : 분리할 것인가? 아니면 합칠 것인가?
  - 일반화 : 공통되는 내용을 분리할 것인가? 의도적으로 중복시킬 것인가?
- 리팩토링 => 추상화, 구조화, 일반화의 수준을 정하는 것.
